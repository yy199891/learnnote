#### B树、B+树

**B+树的特征：**

- 有m个子树的中间节点包含有m个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引；
- 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 (而B 树的叶子节点并没有包括全部需要查找的信息)；
- 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)；

**为什么说B+树比B树更适合数据库索引？**

1）B+树的磁盘读写代价更低

2）B+树查询效率更加稳定

3）B+树便于范围查询（最重要的原因，范围查找是数据库的常态）

![img](img/997909-20190728114240297-169990922.png)

#### 哈希冲突

哈希表的主要思想是通过一个哈希函数， 把关键码映射的位置去寻找存放值的地方 ，读取的时候也是直接通过关键码来找到位置并存进去。

**常见的哈希算法**

1） 直接定址法

 f(key) = key 或 f(key) = a*key + b

2） 除留余数法

 f(key) = key % p, p < m。这是最为常见的一种哈希算法。

3） 数字分析法

适用于所有关键字都已知的情况下，根据实际应用确定要选取的部分，尽量避免发生冲突。

4） 平方取中法

先计算出关键字值的平方，然后取平方值中间几位作为散列地址。

5） 随机数法

选择一个随机函数，把关键字的随机函数值作为它的哈希值



计算散列地址所需的时间

关键字的长度

散列表的大小

关键字的分布情况

记录查找的频率

**哈希冲突解决办法**

开放地址法和链地址法。

一、开放地址法

开发地址法的做法是，当冲突发生时，使用某种探测算法在散列表中寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。按照探测序列的方法，一般将开放地址法区分为**线性探查法、二次探查法、双重散列法**等。

二、链址法将互为同义词的结点链成一个但链表，而将此链表的头指针放在散列表T[0..m-1]中。

https://www.cnblogs.com/wwjj4811/p/14304496.html

## 二叉查找树[#](https://www.cnblogs.com/wwjj4811/p/14304496.html#二叉查找树)

二叉查找树又称二叉搜索树。

它具有以下性质：

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
- 任意结点的左、右子树也分别为二叉搜索树

二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。

## 平衡二叉树[#](https://www.cnblogs.com/wwjj4811/p/14304496.html#平衡二叉树)

平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

特点：

- 具有二叉查找树的全部特性。
- 每个节点的左子树和右子树的高度差至多等于1

## 红黑树

平衡树解决了二叉查找树退化为近似链表的缺点，不过不是最佳方案。因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。

**红黑树的性质：**

**性质1：**每个节点要么是黑色，要么是红色。

**性质2：**根节点是黑色

**性质3：**每个叶子节点(NIL)是黑色

**性质4：**每个红色节点的两个子节点一定都是黑色，不能有两个红色节点相连

**性质5：**任意一节点到每个叶子节点的路径都包含数量相同的黑结点。

### **1、海量日志数据，提取出某日访问百度次数最多的那个IP**

1。分而治之/hash映射：针对数据太大，内存受限，只能是：把大文件化成(取模映射)小文件，即16字方针：大而化小，各个击破，缩小规模，逐个解决
2。hash_map统计：当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。
3。堆/快速排序：统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。

## **2、寻找热门查询，300万个查询字符串中统计最热门的10个\**查询\****

1.hash_map统计：先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。最终我们在O(N)的时间复杂度内用Hash表完成了统计；
2.堆排序：第二步、借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O（N） + N' * O（logK），（N为1000万，N’为300万）。

## **3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词**

1.分而治之/hash映射：顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,...x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。
2.hash_map统计：对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。
3.堆/归并排序：取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。

## **4、海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10。**

1.堆排序：在每台电脑上求出TOP10，可以采用包含10个元素的堆完成

2.求出每台电脑上的TOP10后，然后把这100台电脑上的TOP10组合起来，共1000个数据，再利用上面类似的方法求出TOP10就可以了。

## **5、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。**

1.hash映射：顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。
2.hash_map统计：找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query,query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。
3.堆/快速/归并排序：利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。

## **6、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？**

分而治之/hash映射：遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为，这里漏写个了a1）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。
hash_set统计：求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。
https://blog.csdn.net/v_july_v/article/details/7382693

![](/sort.png)