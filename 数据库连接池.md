#### 数据库连接池是怎么提高效率的？

一般来说，对于数据库操作都是在访问数据库的时候创建连接，访问完毕断开连接，但是在高并发的情况下，有些需要频繁处理的操作就会消耗很多的资源和时间，比如：

1、建立通信连接的TCP三次握手

2、数据库服务器的连接认证

3、数据库服务器关闭连接时的资源回收

4、断开通信连接的TCP四次挥手

所以使用数据库连接池，在这个连接池中需要提前和数据库服务器建立若干个连接，当需要通信时，套钳字的服务器端通过多线程从连接池里取出一个可用的连接，取出这个连接后就可以和数据库服务器进行通信了，通信结束后这个连接是不需要断开的，网络通信的服务器端对应的线程把这个连接在还给数据库连接池，因此就实现了数据库连接 的复用，通过这样的操作大大降低了数据库连接的创建和销毁的次数，对应的时间也就被节省出来了。

#### 为什么使用单例的数据库连接池？

因为在网络服务器中一个连接池就够了，在数据库连接池中提供了若干个连接，只需要一个数据库连接池对象，就可以把多个连接取出来，所以对象一个就够，因此在编写数据库连接池对应的类的时候，这个类应该是单例模式的类，提供单例模式的类可以避免创建多个数据库连接池对象。



#### 怎么知道要销毁那些数据库连接？

当我们创建一个数据库连接之后，他肯定是空闲的，把时间记录下来，即给他一个时间戳，在提供一个线程专门去检测这些数据库连接都空闲了多长时间，就是以现在是时间点减去对应的起始时间点， 如果这个时间长度超过了规定的时长，那就把对应的数据库连接销毁掉，如果没有超过规定时长，就继续存活。



#### 生产者消费者模型

可以把多线程和线程池看作一个生产者消费者模型，消费者就是网络服务器的通信端提供的多个线程，生产者是我们在实现数据库连接池时提供的额外线程，这个线程需要检测数据库连接池中的连接数量是不是没有了，如果连接不够了，这个线程就去生产新的连接，如果连接池里的连接时足够的，那么专门负责生产连接池中的连接就不工作，如果不工作就需要让线程阻塞（条件变量） 

#### 单例模式

##### 1、懒汉	在使用这个实例对象时才去创建它

（1）使用静态的局部变量 （c++11没有线程安全问题）

​		获得一个局部的静态对象

（2）使用互斥锁

（3）使用c++11 call_once实现

##### 2、饿汉	不管用不用这个实例对象，只要这个类被创建出来了，对应的实例对象就有了

​	不存在多线程安全问题

#### json

为了连接任意数据库，因此连接数据库的数据，需要让使用者传递给程序，使用配置文件传递，用标准格式，（xml，json）

存储到json对象中更为直观

#### 通过智能指针来回收处理好的数据库连接

当共享智能指针管理的对象析构时，会先析构管理的智能指针，但是所管理的指针不需要析构，因为使用数据库连接池的目的就是避免数据库连接的频繁创建和销毁，所以 共享指针对象析构的时候。并不是要把智能指针所管理的对象析构，而是让地址回收，因此需要手动去只能共享指针的删除器对应的处理动作，（使用lambda）



#### 测试

连接池，单线程，用时4560毫秒

进行非线程池，多线程时，插入数据失败，因为每个线程的函数里会创建多个数据库连接，多个线程会使用相同的用户名和密码同时登陆mysql服务器，mysql会拒绝一些连接，连接被拒绝了，插入数据失败

解决方法：在启动这些子线程之前，在上面在进行一次额外的连接就可以避免这样的问题。

非连接池，单线程，用时：38067067600纳秒，38067 毫秒

连接池，单线程，用时：4529053900纳秒，4529 毫秒

非连接池，多线程，用时：8394865300纳秒，8394 毫秒

连接池，多线程，用时：1433021000纳秒，1433 毫秒

#### 介绍

做了个数据库连接池，因为是基于MySQL的，所以先对mysql的api进行了封装，并且使用jsoncpp库来解析配置文件中的数据库的相关信息（比如ip，端口，用户名，密码，数据库等）；

使用单例模式来设计这个连接池类，因为连接池只需要一个实例，

所有的数据库连接使用stl中的queue来维护，并使用c++11中的互斥锁来保证线程安全，

使用生产者消费者模型，来生产和处理连接，主要用一个单独的线程来专门检测连接池中的连接是不是够用；

在单独使用一个线程，来检测是不是有多余的连接，主要用到了c++11中chrono库里的一些函数；

当数据库操作完毕后，需要将连接归还连接池，这里主要用到了智能指针，并用lambda表达式重写删除函数。



