---
typora-root-url: img
---

#### 1、OSI7层网络模型：

应用层、表示层、会话层、运输层、网络层、链路层、物理层

#### 2、TCP/IP四层网络模型：

应用层、运输层、网际层、接口层

#### 综合OSI与TCP/IP模型，学习五层网络模型：

从上向下架构：应用层、运输层、网络层、链路层、物理层

## **链路层：**

#### 3、MTU 

最大传送单元(Maximum Transfer Unit)   规定了所能传送的帧的数据部分长度上限

默认值1500字节

#### 4、MAC地址

（Media Access Control Address）与网卡绑定，代表物理地址。

MAC地址用来识别数据链路层中相连的节点

MAC地址长度为48位(6字节)，一般用16进制数字加冒号的形式表示(例如：08:00:27:03:fb:19)

## **网络层：**

#### 5、地址解析协议

ARP解决这样一个问题：已经知道了一个机器(主机或者路由器)的IP地址，找出其相应的硬件地址。

```
 首先，每台主机都会在自己的ARP缓冲区中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP列表中是否存在该 IP地址对应的MAC地址，如果有，就直接将数据包发送到这个MAC地址；如果没有，就向本地网段发起一个ARP请求的广播包，查询此目的主机对应的MAC地址。此ARP请求数据包里包括源主机的IP地址、硬件地址、以及目的主机的IP地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的MAC地址和IP地址添加到自己的ARP列表中，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个 ARP响应数据包，告诉对方自己是它需要查找的MAC地址；源主机收到这个ARP响应数据包后，将得到的目的主机的IP地址和MAC地址添加到自己的ARP列表中，并利用此信息开始数据的传输。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
```

#### 6、为啥有IP地址还需要MAC地址？同理，为啥有了MAC地址还需要IP地址？

##### 为啥有IP地址还需要MAC地址？

1.整体与局部，信息传递时候，需要知道的其实是两个地址：终点地址和下一跳地址。而MAC地址起到了记录下一跳的信息的作用。

2.分层实现，使用MAC地址和IP地址分别用于表示物理地址和逻辑地址，这样分层可以使网络层和链路层的协议更灵活的替换

3.早期以太网的实现，早期只有集线器没有交换机，所以发出去的包能被以太网内所有机器监听到，因此附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。

##### 为啥有了MAC地址还需要IP地址？

使用抽象的IP地址，是为了隐蔽各种底层网络的复杂性而便于分析和研究问题。

1. 只拥有MAC地址的话，只有在同一网络区域内，才能进行数据传输，不能跨网络区域。
2. 如果想跨网络区域进行数据传递，最现实的方法就是借助ISP提供的网络区域。
3. ISP能提供全球互联的网络——因特网，借助因特网可以传输数据给连接因特网上的机器。

#### 7、网络层转发数据报的流程

当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的IP地址后，送交给数据链路层的网络接口软件，利用ARP得出硬件地址，根据硬件地址找到下一跳路由器，封装成帧通过物理层发送。重复。

#### 8、子网划分、子网掩码

子网划分：划分子网只是把IP地址的主机号这部分进行再划分，而不改变IP地址原来的网络号。对外仍然表现为一个网络。

子网掩码：解决的问题是，已知一个数据报目的地址到达路由器R1，如何转发到子网。

把IP地址的子网掩码和收到的数据报的目的IP地址逐位相与，得出所要找的子网的网络地址

#### 9、网络控制报文协议ICMP

种类：ICMP差错报告报文，ICMP询问报文

- ICMP允许主机或路由器报告差错情况和提供异常情况的报告。

- ICMP报文装在IP数据报中。

- ICMP作为IP数据报的数据部分，加上数据报的首部组成IP数据报发出去。

  ![image-20220128190259980](/image-20220128190259980.png)

提取收到的数据报的数据字段前8个字节是为了得到运输层的端口号以及运输层报文的发送序号。

#### 10、ICMP应用举例：PING、traceroute

ping，用来测试两台主机之间的连通性，使用了ICMP回送请求和回送回答报文

traceroute：用来跟踪一个分组从源点到终点的路径，互联网的路由选择协议

## **运输层：**

#### 11、TCP与UDP的区别及应用场景

TCP：传输控制协议，是一种面向连接的可靠传输协议。

UDP：用户数据报协议，是一种非面向连接的不可靠传输协议。

##### 区别：

1.TCP面向连接，UDP是无连接的，即发送数据前不需要建立连接。

2.TCP提供可靠的服务，即通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP只尽最大努力交付，不保证可靠交付。

3.TCP面向字节流，UDP面向报文。

4.TCP只能是一对一；UDP支持一对一，一对多，多对多的交互通信。

5.TCP首部开销大，20字节；UDP首部开销小，只有8个字节、

6.UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或者广播通信。

##### 应用场景：

TCP：对网路通信质量有要求的时候，如HTTP,HTTPS,FTP

UDP：效率要求相对高，对准确性要求相对低的场景，如网络电话，广播通信等。

#### 12、TCP首部报文格式（SYN、ACK、FIN、RST必须知道）

<img src="image-20220129132146204.png" alt="image-20220129132146204" style="zoom:50%;" />

**ACK**：确认，仅当ACK=1时确认号字段才有效。当ACK=0时确认号无效。TCP规定，在连接建立后，所有传达的报文段都必须把ACK置1.

**RST**：复位，当RST=1时，表明TCP连接中出现严重差错，RST置1还用来拒绝一个非法的报文段或拒绝打开一个连接。

**SYN**：同步，在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是个连接请求报文，若对方同意建立连接，则应在响应的报文段中使SYN=1和ACK=1.因此，SYN置1就表明这是一个连接请求或连接接受报文。

**FIN**：终止，用来释放一个连接。当FIN=1时，表明此报文段的发送方的数据已经发送完毕，并要求释放运输连接。

#### 13、TCP滑动窗口原理

滑动窗口是一种流量控制技术。滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接受任何应答之前传送附加的包。接受方发送在某一时刻能送多少包（称窗口尺寸）。

TCP中采用滑动窗口来进行传送控制，滑动窗口的大小意味着接受方还有多大的缓存区可以用于接受数据，发送方可以通过滑动窗口的大小来确定发送多少字节的数据。当滑动窗口为0时，发送方一般不能再发送数据报。

滑动窗口是TCP中实现诸如ACK确认、流量控制，拥塞控制的承载结构。

#### 14、TCP超时重传时间选择

RTT报文段的往返时间

新的RTTS=(1-a)x旧的RTTS+ax新的RTT

RTO超时重传时间

RTO=RTTS+4xRTTd

#### 15、TCP流量控制

所谓流量控制就是让发送方的发送速率不要太快，要让接受方来得及接受。利用滑动窗口进行流量控制

#### 16、TCP拥塞控制（一定要弄清楚与流量控制的区别）

所谓拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或者链路不至过载，拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。

相反流量控制是一个点到点的通信量的控制，所要做的就是抑制发送端发送的数据的速率，以使接收端来得及接收。

拥塞控制的方法：

慢开始，拥塞避免，快重传，快恢复

慢开始：由小到大逐渐增大发送窗口。也就是说，由小到大逐渐增大拥塞窗口数值。

拥塞避免：让拥塞窗口缓慢地增加，即每经过一个往返时间RTT就把发送方的拥塞窗口加1，比慢开始增长速率慢得多。

快重传：可以让发送方尽早直到发生了个别报文段的丢失。要求不要等待自己发送数据是才捎带确认，而是立即发送，规定只要发送方一连接受3个重复确认就知道接收方没有收到报文段。

快恢复：一旦出现超时或者3个重复的确认，就把门限值设置为当前拥塞窗口值的一半，并大幅减少拥塞窗口的数值。

![image-20220129144944548](image-20220129144944548.png)

#### 17、TCP三次握手及状态变化。为啥不是两次握手？

A客户端，B服务端，

1.第一次握手

B处于listen状态，等待A的连接请求。A向B发送连接请求报文段，同步位SYN=1，选择初始序号seq=x，A进入SYN_SENT状态。

2.第二次握手

B收到请求报文段，同意建立连接，向A发送确认报文段，SYN=1,ACK=1，确认号ack=x+1，初始序号seq=y，进入SYN_RCVD状态。

3.第三次握手

A收到B的确认后，还要向B发送确认，ACK=1，ack=y+1.此时建立连接，A和B都进入ESTABLISHED状态。

```
已失效的连接请求报文段”的产生在这样一种情况下：

client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。

本来这是一个早已失效的报文段,但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。

于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。

由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据,但server却以为新的运输连接已经建立，并一直等待client发来数据。

这样，server的很多资源就白白浪费掉了
```

如果第二次握手就建立连接的话，客户端不会搭理服务端，服务端浪费资源。

![image-20220129153727444](image-20220129153727444.png)

#### 18、TCP四次挥手及状态变化。为啥不是三次挥手？

A客户端，B服务端都处于ESTABLESHED状态

1.第一次挥手

A把连接释放报文段的首部终止控制位FIN=1，序号seq=u，A进入FIN_WAIT_1状态。

2.第二次挥手

B收到连接释放报文段，发出确认好ACK=1,ack=u+1，进入CLOSE_WAIT阶段，此时连接处于半关闭状态。A收到确认后进入FIN_WAIT_2状态，等待B发出的连接释放报文段。

3.第三次挥手

若B没有要发的数据，此时B发出连接释放报文段FIN=1，序号seq=w，确认号ack = u+1,B进入LAST_ACK状态。

4.第四次挥手

A收到B的连接释放报文段后，必须发出确认。ACK=1,ack = w+1,seq = u+1，进入TIME_WAIT状态。此时TCP连接还未完全释放，必须经过时间等待计时器设置的2MSL后，进入CLOSE,B收到A的确认后CLOSE。

MSL(最长报文段寿命) 为了保证A发送的最后一个ACK能够被B收到

**服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，从而比三次握手导致多了一次。**

![image-20220129153733393](image-20220129153733393.png)

#### 19、TCP连接释放中TIME_WAIT状态的作用

1.为了保证A发送的最后一个ACK报文段能够到达B

2.确保所有本次连接的报文段都在网络中消失了，防止“已失效的连接请求段”出现在本连接中。

#### 20、SYN泛洪攻击。如何解决？

攻击者发送大量TCP SYN报文段，而不完成第三次 的步骤。服务器不断为这些半开连接分配资源，导致服务器连接资源消耗殆尽。

解决方式：

SYN cookie。

1服务器收到SYN报文段，不会生成半开的连接，会生成一个初始TCP序列号，该序列号由SYN报文段的源IP和目的IP，源端口号和目的端口号以及只有服务端知道的秘密数的复杂函数构成。服务器发送这种SYNACK，而不记忆任何信息。

2如果客户合法，返回ACK报文段，只需使用函数结果+1和客户ACK中的确认号相同，那么认定合法，建立全开连接。

3.没有返回ACK报文段，说明是泛洪攻击，由于服务器没有分配任何资源，所以没有产生危害。

#### 21、TCP粘包

TCP粘包就是指发送方发送若干包数据到达接收方时粘成了一包，从接收缓冲区来看，后一包数据的头紧接着前一包数据的尾。

发送方原因，默认使用了Nagle

接受方原因，缓存数据的速度大于应用层从缓存中读取包的速度

#### 22、TCP心跳包

心跳包就是在客户端和服务端间定时通知对方自己状态的命令字，按照一定的时间间隔发送，类似于心跳，所以叫心跳包。

TCP KeepAlive保活机制

#### 23、路由器与交换机的区别

1.功能不同，交换机功能相当于增加网络接口，路由器功能是自动拨号并且传输无线信号

2.分类不同，交换机为普通的局域网交换机和运营商的广域交换机，路由器分为无线连接和有线连接。

3.层级不同，交换机属于数据链路层，路由器属于网络层

#### 24、UDP如何实现可靠传输

在应用层实现确认机制，重传机制，窗口确认机制

发送：包的分片，包的确认，包的重发

接受：包的调序，包的序号确认

## **应用层：**

#### 25、DNS域名系统。采用TCP还是UDP协议？为什么？

域名到IP地址的解析过程：当某个应用进程需要把主机名解析为IP地址时，该应用进程就调用**解析程序**，并成为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用进程获得目的主机的IP地址后即可进行通信。

采用UDP协议，是为了减少开销。

#### 26、FTP协议（了解）

FTP，复制整个文件，特点：若要存取一个文件，就必须先获得一个本地的文件副本。如果要修改文件，只能对文件的副本进行修改，然后再将修改后的文件副本传回到原节点。

#### 27、HTTP请求报文与响应报文首部结构

HTTP请求报文首部结构：

请求方法，URL，协议版本，请求头部

HTTP响应报文首部结构：

协议版本，状态码，状态码描述，响应头部

#### 28、HTTP1.0、HTTP1.1、HTTP2.0对比

**HTTP1.0与HTTP1.1比较**

1.**长连接**：HTTP1.0不支持长连接，每进行一次通信就要断开TCP连接；

HTTP1.1支持长连接，一个TCP连接中可以传送多个HTTP请求和响应，减少了TCP连接重复建立和断开所造成的额外开销，减轻了服务器的负载。

2.**管线化**：HTTP1.0工作方式为非流水线方式，发送请求后需等待并收到相应，才能发送下一个请求；HTTP1.1支持流水线工作方式，可以同时并行发送多个请求，不需要一个接一个地等待响应。

**HTTP2.0在HTTP1.1基础上的改进**

**1.二进制分帧**：HTTP1.1是通过文本的方式传输数据，表现形式具有多样性，而二进制只有0和1两种状态，实现方便且稳定。

**2.首部压缩**：HTTP1.*中header中含有大量信息（特别是包括cookie时），每次都需要重复发送；HTTP2.0采用头部压缩算法对传输的header进行编码，并在客户端和服务端维护一张索引表来记录出现过的header，后面在传输过程中就可以传输已经记录过的header的键名，对端收到数据后就可以通过键名找到相应的值。

**3.多路复用**：HTTP1.1虽然支持并发多个请求，但页面需要请求很多资源时，队头阻塞会导致在达到最大请求时，会阻碍排在后面的请求；HTTP2.0可以同时处理多个消息和响应，甚至交错发送数据，避免了队头阻塞问题，提高传输性能。

**4.服务器推送**：HTTP1.1中，一个客户端的请求对应一个响应。在HTTP2.0中，服务器可以对一个客户端的请求发送多个响应。

#### 29、HTTP与HTTPS对比

1.HTTP明文传输，数据都是未加密的，安全性较差，HTTPS(SSL+HTTP)数据传输过程都是加密的，安全性较好。

2.使用HTTPS协议需要CA(数字证书认证机构)申请证书，HTTP不需要

3.HTTP页面响应速度比HTTPS快，因为HTTP需要TCP三次握手建立连接，而HTTPS除了TCP3个包，还要加上ssl握手9个包

4.HTTP和HTTPS用的端口不一样，前者80，后者443

5.HTTPS其实就是建立在SSL/TLS之上的HTTP协议，所以HTTPS比HTTP更消耗资源

SSL（Secure Socket Layer，安全套接字层）TLS(Transport Layer Security，传输层安全协议)

#### 30、HTTPS加密流程

1.客户端发起HTTPS请求，浏览器输入https网址，连接到server443端口

2.服务器证书生成公钥和私钥并响应公钥

3.客户端解析证书，验证是否有效

4.客户端生成随机key并传送给服务端

5.服务端使用私钥解密信息，得到随机key，并利用随机key将内容加密传送给客户端

6.客户端利用随机key解密信息

#### 31、方法：GET、HEAD、POST、PUT、DELETE

(1) GET：请求读取由URL所标志的信息

(2) HEAD：请求读取由URL所标志的信息首部

(3) POST：给服务器添加信息

(4) PUT：给指明的URL下存储一个文档

(5) DELETE：删除指明的URL所标志的资源

#### 32、状态码：1**、2**、3**、4**、5**

(1) 1**：表示通知信息的，如接受的请求正在处理

(2) 2**：表示成功，如请求正常处理完毕

​	200(OK)：表示从客户端发来的请求在服务端被正常处理；

(3) 3**：表示重定向，如需要进行附加操作来完成请求

(4) 4**：表示客户端的差错，如请求中有服务器无法识别的语法；

(5) 5**：表示服务器的差错，如服务器上无法找到请求。

#### 33、cookie与session区别

cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。

**1.cookie工作原理**

(1)客户端第一次发送请求给服务端

(2)服务端创建cookie(包含用户的信息，对应一个识别码)，并发送给客户端，客户端会保存cookie

(3)客户端再次访问服务端时，会自动在请求报文段中加入cookie值发送给服务端。

(4)服务端接受报文后，通过cookie值就能确认用户身份。

**2.session工作原理**

(1)客户端第一次访问服务端

(2)服务端创建一个sessionid和session形成一个映射关系，session保存在后端数据库，然后将sessionid发送给客户端并保存；

(3)客户端再次访问服务端时，会自动在请求报文的首部行加入sessionid

(4)服务端根据sessionid去查询session对象，从而区分不同的用户

**3.比较**

(1)cookie数据存放在客户端，session存放在服务端

(2)cookie不是很安全，攻击者可以分析客户端本地的cookie进行身份伪装，考虑到安全问题可以使用session

(3)单个cookie在客户端的数据大小限制为4k，session过多时会消耗服务器资源

#### 34、输入一个URL到显示页面的流程（越详细越好，搞明白这个，网络这块就差不多了）

1.在浏览器里输入网址

2.浏览器查找域名的IP地址，DNS域名解析。

​	浏览器缓存，系统缓存，路由器缓存，ISP DNS缓存从根域名服务器递归搜索

3.建立TCP连接，三次握手

4.浏览器给web服务器发送一个HTTP请求

5.服务器处理请求

6.服务器发回一个HTML响应

7.关闭TCP连接，四次握手

8.浏览器解析HTML

9.浏览器布局渲染