#### 在排序数组中查找数字 I

**排序数组**中的搜索问题，首先想到 **二分法** 解决。

本题要求统计数字 target 的出现次数，可转化为：使用二分法分别找到 左边界 left 和 右边界 right ，易得数字 target 的数量为 right - left - 1 。

算法解析：
	初始化： 左边界 i = 0i=0 ，右边界 j = len(nums) - 1 。
	循环二分： 当闭区间 [i, j][i,j] 无元素时跳出；
	计算中点 m = (i + j) / 2（向下取整）；
	若 nums[m] < target ，则 target 在闭区间 [m + 1, j][m+1,j] 中，因此执行 i = m + 1；
	若 nums[m] > target ，则 target 在闭区间 [i, m - 1][i,m−1] 中，因此执行 j = m - 1；
	若 nums[m] = target ，则右边界 right 在闭区间 [m+1, j][m+1,j] 中；左边界 left 在闭区间 [i, m-1][i,m−1] 中。因此分为以	下两种情况：
		**若查找 右边界 right ，则执行 i = m + 1 ；（跳出时 i 指向右边界）**
		**若查找 左边界 left ，则执行 j = m - 1 ；（跳出时 j 指向左边界）**
返回值： 应用两次二分，分别查找 right 和 left ，最终返回 right - left - 1 即可。

效率优化：
以下优化基于：查找完右边界 right = i 后，则 nums[j] 指向最右边的 target （若存在）

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        //find right
        int l = 0, r = nums.size() - 1;
        while(l <= r) {
            int m = (l + r) / 2;
            if(nums[m] <= target) {
                l = m + 1;
            } else {
                r = m - 1;
            }
        }

        int right = l;
        //判断数组中是否有target 没有就直接返回
        if(r > 0 && nums[r] != target) return 0;

        //find left
        l = 0, r = nums.size() - 1;
        while(l <= r) {
            int m = (l + r) / 2;
            if(nums[m] < target) {
                l = m + 1;
            } else {
                r = m - 1;
            }
        }
        int left = r;
        return right - left -1;
    }
};
```

### 二叉树的迭代遍历

```c++
class solution{
public:
    vector<int> inorderTraversal(TreeNode* root) {  //中序遍历
		vector<int> res;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
			TreeNode* Node = st.top();
            if(Node != NULL) {
				st.pop();  //将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                if(Node->right) st.push(Node->right); //右
                st.push(Node);		//中
                st.push(NULL);  // 中节点访问过，但是还没有处理，加入空节点作为标记
                if(Node->left) st.push(Node->left); //左
            } else {  //只有遇到空节点的时候，才将下一个节点放入结果集
				st.pop();  //将空节点弹出
                Node = st.top();  //重新取出栈中元素
                st.pop();
                res.push_back(Node->val);  //加入到结果集
            }
        }
        return res;
    }
};
```



#### [ 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

```c++
class Solution {
public:
    vector<int> levelOrder(TreeNode* root) {
        vector<int> v;
        if(root == NULL) return v;
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()) {
            int levelsize = q.size();
            for(int i = 0; i < levelsize; i++) {
                auto Node = q.front();
                q.pop();
                v.push_back(Node->val);
                if(Node->left) q.push(Node->left);
                if(Node->right) q.push(Node->right);
            }
        }
        return v;
    }
};
```

#### [树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```c++
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(A == NULL || B == NULL) {
            return false;
        }
        return rerur(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }

    bool rerur(TreeNode* A, TreeNode* B) {
        if(B == NULL) return true;
        if(A == NULL) return false;
        if(A->val != B->val) return false;
        return rerur(A->left, B->left) && rerur(A->right, B->right);
    }
};
```

#### [二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

```c++
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root) return root;
        TreeNode* temp = root->right;
        root->left = mirrorTree(root->right);
        temp = mirrorTree(root->left);
        return root;
    }
};
class Solution {
public:
    TreeNode* mirrorTree(TreeNode* root) {
        if(!root) return root;
        stack<TreeNode*> s;
        s.push(root);
        while(!s.empty()) {
            int len = s.size();
            for(int i = 0; i < len; i++) {
                TreeNode* Node = s.top();
                s.pop();
                if(Node->left) s.push(Node->left);
                if(Node->right) s.push(Node->right);
                swap(Node->left, Node->right);
            }        
        }
        return root;
    }
};
```

#### [ 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return rerur(root->left, root->right);
    }

    bool rerur(TreeNode* l, TreeNode* r) {
        if(!l && !r) return true;
        if(!l || !r || l->val != r->val) return false;
        return rerur(l->left, r->right) && rerur(l->right, r->left);
    }
};
```



#### [斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

```c++
class Solution {
public:
    int fib(int n) {
        int a = 0, b = 1, sum = 1;
        for(int i = 0; i < n; i++) {
            sum = (a + b) % 1000000007;
            a = b;
            b = sum;
        }
        return a;
    }
};
```

#### [股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit = 0, minprice = INT_MAX;
        for(auto price : prices) {
            minprice = min(minprice, price);
            profit = max(profit, price - minprice);
        }
        return profit;
    }
};
```

#### [接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

```c++
class Solution {
public:
    int trap(vector<int>& height) {
        int len = height.size();
        vector<int> leftmax(len);
        vector<int> rightmax(len);
        for(int i = 1; i < len - 1; i++){
            leftmax[i] = max(leftmax[i - 1], height[i - 1]);
        }
        for(int i = len - 2; i >= 0; i--) {
            rightmax[i] = max(rightmax[i + 1], height[i + 1]);
        }
        int sum = 0;
        for(int i = 1; i < len - 1; i++) {
            int min = std::min(leftmax[i], rightmax[i]);
            if(min > height[i]) {
                sum += min - height[i];
            }
        }
        return sum;
    }
};
```

#### [连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size() == 0) return 0;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int res = dp[0];
        for(int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            if(dp[i] > res) res = dp[i];
        }
        return res;
    }
};
```



#### [最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

```c++
双指针
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> dic;
        int res = 0, i = -1;
        for(int j = 0; j < s.length(); j++) {
            if(dic.count(s[j])) {
                i = max(i, dic[s[j]]);
            }    
            dic[s[j]] = j;
            res = max(res, j - i);
        }
        return res;
    }
};
```

```c++
滑动窗口
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_map<char, int> win;
        int left = 0, right = 0;
        int res = 0;
        while(right < s.length()) {
            char c1 = s[right];
            right++;
            win[c1]++;
            while(win[c1] > 1) {
                char c2 = s[left];
                left++;
                win[c2]--;
            }
            res = max(res, right - left);
        }
        return res;
    }
};
```

#### [ 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

```c++
class Solution {
public:
    ListNode* deleteNode(ListNode* head, int val) {
        ListNode* cur = head;
        if(cur->val == val) return head->next;
        ListNode* pre = NULL;
        while(cur->val != val) {
            pre = cur;
            cur = cur->next;
        }
        pre->next = cur->next;
        return head; 
    }
};
//有重复节点
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dum = new ListNode(0);
        dum->next = head;
        ListNode* cur = dum;
        while(cur->next) {
            if(cur->next->val == val) {
                ListNode* temp = cur->next;
                cur->next = cur->next->next;
                delete temp;
            } else {
                cur = cur->next;
            }
        }
        head = dum->next;
        delete dum;
        return head;
    }
};
```

#### [翻转单词顺序](https://letcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/)

```c++
class Solution {
public:
    string reverseWords(string s) {
        s += " ";
        string temp = "";
        vector<string> res;
        for(auto ch : s) {
            if(ch == ' ') {
                if(!temp.empty()) {
                    res.push_back(temp);
                    temp.clear();
                }
            } else {
                temp += ch;
            }
        }
        s.clear();
        reverse(res.begin(), res.end());
        for(auto it : res) {
            s += it + ' ';
        }
        s.pop_back();
        return s;
    }
};
```



#### [矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

```c++
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        row = board.size();
        col = board[0].size();
        int k = 0;
        for(int i = 0; i < row; ++i) {
            for(int j = 0; j < col; ++j) {
                if(DFS(board, word, i, j, k)) return true;
            }
        }
        return false;
    }
private:
    int row, col;
    bool DFS(vector<vector<char>>& board, string word, int i, int j, int k) {
        if(i < 0 || i >= row || j < 0 || j >= col || board[i][j] != word[k]) return false;
        if(k == word.size() - 1) return true;
        board[i][j] = '\0';
        bool res = (DFS(board, word, i + 1, j, k + 1) || DFS(board, word, i - 1, j, k + 1) 
                || DFS(board, word, i, j + 1, k + 1) || DFS(board, word, i, j - 1, k + 1));
        board[i][j] = word[k];
        return res;
    }
};
```

#### [机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

![image-20220129203801601](C:\Users\yy\AppData\Roaming\Typora\typora-user-images\image-20220129203801601.png)

```c++
class Solution {
public:
    int movingCount(int m, int n, int k) {
        vector<vector<bool>> visited(m, vector<bool>(n, 0));
        return dfs(0, 0, 0, 0, visited, m, n, k);
    }
private:
    int dfs(int i, int j, int si, int sj, vector<vector<bool>> &visited, int m, int n, int k) {
        if(i >= m || j >= n || k < si + sj || visited[i][j]) return 0;
        visited[i][j] = true;
        return 1 + dfs(i + 1, j, (i + 1) % 10 != 0 ? si + 1 : si - 8, sj, visited, m, n, k) +
                   dfs(i, j + 1, si, (j + 1) % 10 != 0 ? sj + 1 : sj - 8, visited, m, n, k);
    }
};

```

![image-20220129203840068](C:\Users\yy\AppData\Roaming\Typora\typora-user-images\image-20220129203840068.png)

```c++
class Solution {
public:
    int movingCount(int m, int n, int k) {
        vector<vector<bool>> visited(m, vector<bool>(n, 0));
        queue<vector<int>> que;
        int res = 0;
        que.push({0, 0, 0, 0});
        while(que.size() > 0) {
            vector<int> x = que.front();
            que.pop();
            int i = x[0], j = x[1], si = x[2], sj = x[3];
            if(i >= m || j >= n || si + sj > k || visited[i][j]) continue;
            visited[i][j] = true;
            res++;
            que.push({i + 1, j, bitsum(i + 1), bitsum(j)});
            que.push({i, j + 1, bitsum(i), bitsum(j + 1)});
        }
        return res;
    }
    int bitsum(int x) {
        int sum = 0;
        while(x > 0) {
            sum += x % 10;
            x = x / 10;
        }
        return sum;
    }
};
```

## [二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

前序+回溯

```c++
class Solution {
public:
    vector<vector<int>> ans;

    void PreOrderTraverse(TreeNode* root, int target, vector<int> vec, int sum) {
        if(!root) return;
        sum += root->val;
        vec.push_back(root->val);
        if(sum == target && !root->left && !root->right) ans.push_back(vec);
        PreOrderTraverse(root->left, target, vec, sum);
        PreOrderTraverse(root->right, target, vec, sum);
        sum -= root->val;
        vec.pop_back();
    }

    vector<vector<int>> pathSum(TreeNode* root, int target) {
        vector<int> vec;
        int sum = 0;
        PreOrderTraverse(root, target, vec, sum);
        return ans;
    }
};
```

## [二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```c++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        string path;
        if(root == nullptr) return res;
        dfs(root, path, res);
        return res;
    }

    void dfs(TreeNode* root, string path, vector<string>& res) {
        path += to_string(root->val);
        if(!root->left && !root->right) {
            res.push_back(path);
            return;
        }
        if(root->left) dfs(root->left, path + "->", res);
        if(root->right) dfs(root->right, path + "->", res);
    }
};
```

## [路径总和](https://leetcode-cn.com/problems/path-sum/)

```c++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum){
		if(root == nullptr) return false;
       	if(!root->left && !root->right && targetSum - root->val == 0) {
            return true;
        }
        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);
    }
};
```



#### [二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

中序+回溯

```c++
class Solution {
public:
    Node* pre;
    Node* head;

    Node* treeToDoublyList(Node* root) {
        if(root == nullptr) return nullptr;
        InOrder(root);
        head->left = pre;
        pre->right = head;
        return head;
    }

    void InOrder(Node* root) {
        if(root == nullptr) return;
        InOrder(root->left);
        if(pre != nullptr) pre->right = root;
        else head = root;
        root->left = pre;
        pre = root;
        InOrder(root->right);
    }
};
```

#### [二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

倒序中序（目标值引用，传引用 这里需要保证所有dfs函数共用一个k ）

```c++
class Solution {
public:
    int res;
    int kthLargest(TreeNode* root, int k) {
        helper(root, k);
        return res;
    }
    void helper(TreeNode* root, int& k) {
        if(!root || k == 0) return;
        helper(root->right, k);
        k--;
        if(k == 0) res = root->val;
        helper(root->left, k);
    }

};
```

#### [最小的k个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)

快排，堆排序

```c++
class Solution {
public:
    vector<int> getLeastNumbers(vector<int>& arr, int k) {
        priority_queue<int> q;
        if(k == 0) return {};
        for(auto num : arr) {
            if(q.size() >= k) {
                if(q.top() > num) {
                    q.push(num);
                    q.pop();
                    }
            }
            else {
                q.push(num);
            }
        }
        vector<int> res;
        while(!q.empty()){
            res.push_back(q.top());
            q.pop();
        }
        return res;
    }
};
```



#### [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root->val < p->val && root->val < q->val) {
            return lowestCommonAncestor(root->right, p, q);
        } else if (root->val > p->val && root->val > q->val) {
            return lowestCommonAncestor(root->left, p, q);
        }
        return root;
    }
};
```

#### [二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

```c++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q) return root;
        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);
        if(left == nullptr) return right;
        if(right == nullptr) return left;
        return root;
    }
};
```

![image-20220204181036439](C:\Users\yy\AppData\Roaming\Typora\typora-user-images\image-20220204181036439.png)

#### [ 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```c++
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        this->preorder = preorder;
        for(int i = 0; i < inorder.size(); i++) {
            dic[inorder[i]] = i;
        }
        return rerur(0, 0, inorder.size() - 1);
    }
private:
    vector<int> preorder;
    unordered_map<int, int> dic;
    TreeNode* rerur(int root, int left, int right) {
        if(left > right) return nullptr;
        TreeNode* Node = new TreeNode(preorder[root]);
        int i = dic[preorder[root]];
        Node->left = rerur(root + 1, left, i - 1);
        Node->right = rerur(root + i - left + 1, i + 1, right);
        return Node;
    }
};
```

![image-20220204184348332](C:\Users\yy\AppData\Roaming\Typora\typora-user-images\image-20220204184348332.png)

**递推参数：**根节点在前序遍历的索引 `root` 、子树在中序遍历的左边界 `left` 、子树在中序遍历的右边界 `right` ；

#### [二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

单调栈

![image-20220204192228352](C:\Users\yy\AppData\Roaming\Typora\typora-user-images\image-20220204192228352.png)

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        stack<int> s;
        int root = INT_MAX;
        for(int i = postorder.size() - 1; i >= 0; i--) {
            if(postorder[i] > root) return false;
            while(!s.empty() && postorder[i] < s.top()) {
                root = s.top();
                s.pop();
            }
            s.push(postorder[i]);
        }
        return true;
    }
};
```

递归分治

```c++
class Solution {
public:
    bool verifyPostorder(vector<int>& postorder) {
        return rerur(postorder, 0, postorder.size() - 1);
    }
    bool rerur(vector<int>& postorder, int left, int right) {
        if(left >= right) return true;
        int p = left;
        while(postorder[p] < postorder[right]) p++;
        int m = p;
        while(postorder[p] > postorder[right]) p++;
        return p == right && rerur(postorder, left, m - 1) && rerur(postorder, m, right - 1);

    }
};
```

#### [剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

```c++
class Solution {
public:
    int cuttingRope(int n) {
        if(n < 4) return n - 1;
        vector<int> res(n + 1, 0);
        res[1] = 1;
        res[2] = 2;
        res[3] = 3;
        for(int i = 4; i <= n; i++) {
            for(int j = 1; j <= i/2; j++) {
                res[i] = max(res[i], max(j * (i - j), j * res[i - j]));
            }
        }
        return res[n];
    }
};
剪了第一段后，剩下(i - j)长度可以剪也可以不剪。如果不剪的话长度乘积即为j * (i - j)；如果剪的话长度乘积即为j * dp[i - j]。取两者最大值max(j * (i - j), j * dp[i - j])
第一段长度j可以取的区间为[2,i)，对所有j不同的情况取最大值，因此最终dp[i]的转移方程为
dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))
```

#### [和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

滑动窗口

```c++
class Solution {
public:
    vector<vector<int>> findContinuousSequence(int target) {
        int i = 1, j = 1, sum = 0;
        vector<vector<int>> res;
        while(i <= target/2) {
            if(sum < target) {
                sum += j;
                j++;
            }
            else if(sum > target) {
                sum -= i;
                i++;
            }
            else {
                vector<int> cur;
                for(int k = i; k < j; k++) {
                    cur.push_back(k);
                }
                res.push_back(cur);
                sum -= i;
                i++;
            }
        }
        return res;
    }
};
```



#### [圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)约瑟夫环

```c++
class Solution {
public:
    int lastRemaining(int n, int m) {
        int x = 0;
        for(int i = 2; i <= n; i++) {
            x = (x + m) % i;
        }
        return x;
    }
};
f(n)=(f(n−1)+t)%n
	=(f(n−1)+m%n)%n
	=(f(n−1)+m)%n

```

#### [栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

```c++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        vector<int> stack;
        int i = 0;
        for(auto num : pushed) {
            stack.push_back(num);
            while(!stack.empty() && stack.back() == popped[i]) {
                stack.pop_back();
                i++;
            }
        }
        return stack.empty();
    }
};
```

#### [把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

//1、去除首部空格

//2、判断符号

//3、开始数字拼接 遇到字母break

```c++
class Solution {
public:
    int strToInt(string str) {
        int len = str.size();
        bool sign = false;
        long int res = 0;
        int i = 0;
        //1.去除首部空格
        while(i < len && str[i] == ' ') {
            i++;
        }
        //2.判断正负
        if(str[i] == '-' || str[i] == '+') {
            str[i] == '-' ? sign = true : sign = false;
            i++;
        }
        //开始数字拼接 遇到字母break;
        while(i < len) {
            if(str[i] < '0' || str[i] > '9') {
                break;
            }
            res *= 10;
            res += str[i] - '0';
            i++;
            if(res > INT_MAX) {
                return sign ? INT_MIN : INT_MAX;
            }
        }
        return sign ? -res : res;
    }
};
```

#### [滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

单调队列

1.队列中仅包含窗口内的元素

2.队列中非严格递减，要删除小于新来的元素

```c++
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> dq;
        vector<int> res;
        int n = nums.size();
        if(n == 0 || k <= 0) return {};
        for(int j = 0, i = 1 - k; j < n; j++, i++) {
            if(i > 0 && nums[i - 1] == dq.front()) dq.pop_front();
            while(!dq.empty() && dq.back() < nums[j]) {
                dq.pop_back();
            }
            dq.push_back(nums[j]);
            if(i >= 0) {
                res.push_back(dq.front());
            }
        }
        return res;
    }
};

class Solution {
public:
class myQue {
public:
    deque<int> dq;
    myQue(){}
    void pop(int val) {
        if(!dq.empty() && val == dq.front()) {
            dq.pop_front();
        }
    }
    void push(int val) {
        while(!dq.empty() && val > dq.back()) {
            dq.pop_back();
        }
        dq.push_back(val);
    }
    int front(){
        return dq.front();
    }
};
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        vector<int> res;
        myQue que;
        for(int i = 0; i < k; i++) {
            que.push(nums[i]); 
        }
        res.push_back(que.front());
        for(int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]);
            que.push(nums[i]);
            res.push_back(que.front());
        }
        return res;
    }
};
```

#### [搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)

```c++
class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int len = nums.size();
        if(len == 0) {
            return false;
        }
        if(len == 1) {
            return nums[0] == target;
        }
        int i = 0, j = len - 1;
        while(i <= j) {
            int m = i + (j - i) / 2;
            if(nums[m] == target) {
                return true;
            }
           if(nums[i] == nums[m]) {
                ++i;
                continue;
            } 
            if(nums[i] <= nums[m]) {
                if(nums[i] <= target && target < nums[m]) {
                    j = m - 1;
                } else {
                    i = m + 1;
                }
            } else {
                if(nums[m] < target && target <= nums[len - 1]) {
                    i = m + 1;
                } else {
                    j = m - 1;
                }
            }
        }
        return false;
    }
};
```

#### [下一个排列](https://leetcode-cn.com/problems/next-permutation/)

```c++
class Solution {
public:
    void nextPermutation(vector<int>& nums) 
    {
        int i = nums.size() - 2;
        int j = 0;
        for (; i >= 0; i--)
        {
            if (nums[i] < nums[i + 1])
            {
                j = i + 1;
                break;
            }
        }

        if (i >= 0)
        {
            int k = nums.size() - 1;

            for (; k >= j; k--)
            {
                if (nums[i] < nums[k])
                    break;
            }

            swap(nums[i], nums[k]);
        }

        reverse(nums.begin() + i + 1, nums.end());
    }
};

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int len = nums.size();
        if(len <= 1) return;
        int i = nums.size() - 2, j = nums.size() - 1, k = nums.size() - 1; 
        while(i >= 0 && nums[i] >= nums[j]) {
                i--;
                j--;
        }
        if(i >= 0) {
            while(k >= 0 && nums[i] >= nums[k]) {
                k--;
            }
            swap(nums[i], nums[k]);
        }
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

#### [全排列](https://leetcode-cn.com/problems/permutations/)

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        int len = nums.size();
        vector<int> path;
        vector<bool> used(len, false);
        vector<vector<int>> res;
        if(len == 0) return {};
        dfs(path, used, nums, res, 0, len);
        return res;
    }

    void dfs(vector<int> path, vector<bool> used, vector<int>& nums, vector<vector<int>>& res, int depth, int len) {
        if(len == depth) {
            res.push_back(path);
            return;
        }
        for(int i = 0; i < len; ++i) {
            if(!used[i]) {
                path.push_back(nums[i]);
                used[i] = true;
                dfs(path, used, nums, res, depth + 1, len);
                used[i] = false;
                path.pop_back();
            }
        }
    }
};

```

#### [全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

```c++
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        int len = nums.size();
        if(len <= 0) return {};
        vector<int> path;
        vector<bool> used(len);
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        dfs(path, used, res, nums, 0, len);
        return res;
    }

    void dfs(vector<int>& path, vector<bool>& used, vector<vector<int>>& res, vector<int>& nums, int depth, int len) {
        if(depth == len) {
            res.push_back(path);
            return;
        }

        for(int i = 0; i < len; ++i) {
            if(used[i] || i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            dfs(path, used, res, nums, depth + 1, len);
            used[i] = false;
            path.pop_back();
        }
    }
};
```

#### [组合总和](https://leetcode-cn.com/problems/combination-sum/)

```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        int len = candidates.size();
        if(len <= 0) return {};
        vector<int> path;
        vector<vector<int>> res;
        sort(candidates.begin(), candidates.end());
        dfs(path, candidates, res, len, 0, target);
        return res;
    }

    void dfs(vector<int>& path, vector<int>& candidates, vector<vector<int>>& res, int len, int begin, int target) {
        if(target < 0) return;
        if(0 == target) {
            res.push_back(path);
            return;
        }
        for(int i = begin; i < len; ++i) {
            path.push_back(candidates[i]);
            dfs(path, candidates, res, len, i, target - candidates[i]);
            path.pop_back();
        }
    }
};
什么时候使用 used 数组，什么时候使用 begin 变量
有些朋友可能会疑惑什么时候使用 used 数组，什么时候使用 begin 变量。这里为大家简单总结一下：

排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；
组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 begin 变量。

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/combination-sum/solution/hui-su-suan-fa-jian-zhi-python-dai-ma-java-dai-m-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [三数之和](https://leetcode-cn.com/problems/3sum/)

```c++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int len = nums.size();
        if(len < 3) return {};
        sort(nums.begin(), nums.end());
        vector<vector<int>> res;
        for(int k = 0; k < len - 2; ++k) {
            if(nums[k] > 0) {
               continue; 
            }
            if(k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            int i = k + 1, j = len - 1;
            while(i < j) {
                int sum = nums[k] + nums[i] + nums[j];
                if(sum < 0) {
                    while(i < j && nums[i] == nums[++i]);
                } else if(sum > 0) {
                    while(i < j && nums[j] == nums[--j]);
                } else {
                    res.push_back({nums[k], nums[i], nums[j]});
                    while(i < j && nums[i] == nums[++i]);
                    while(i < j && nums[j] == nums[--j]);
                }
            }
        }
        return res;
    }
};
```

#### [分割回文子字符串](https://leetcode-cn.com/problems/M99OJA/)

```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<vector<string>> partition(string s) {
        vector<string> path;
        dfs(path, 0, s);
        return res;
    }

    void dfs(vector<string>& path, int begin, string& s) {
        if(begin == s.size()) {
            res.push_back(path);
            return;
        }

        for(int end = begin; end < s.size(); end++) {
            if(isPalindrome(s, begin, end)) {
                path.push_back(s.substr(begin, end - begin + 1));
                dfs(path, end + 1, s);
                path.pop_back();
            }
        }
    }
    
    bool isPalindrome(string& s, int left, int right) {
        while(left < right) {
            if(s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
    }
};
```

#### 回溯模版

```c++
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}

```

#### [复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

```c++
class Solution {
public:
    vector<string> res;


    void traceback(string& s, int startindex, int pointnum) {
        if(pointnum == 3) {
            if(isValid(s, startindex, s.size() - 1)) {
                res.push_back(s);
            }
            return;
        }
        for(int i = startindex; i < s.size(); i++) {
            if(isValid(s, startindex, i)) {
            s.insert(s.begin() + i + 1, '.');
            pointnum++;
            traceback(s, i + 2, pointnum);
            pointnum--;
            s.erase(s.begin() + i + 1);
            } else break;
        }
    }
        bool isValid(const string& s, int start, int end) {
        if(start > end) {
            return false;
        }
        if(s[start] == '0' && start != end) {
            return false;
        }
        int num = 0;
        for(int i = start; i <= end; i++) {
            if(s[i] > '9' || s[i] < '0') {
                return false;
            }
            num = num * 10 + (s[i] - '0');
            if(num > 255) {
                return false;
            }
        }
        return true;
    }

    vector<string> restoreIpAddresses(string s) {
        res.clear();
        int len = s.size();
        if(len > 12) return res;
        traceback(s, 0, 0);
        return res;
    }

};
```

#### 求二叉树中最远的两个节点的距离

```c++

int GetFarDistance()
       {
              int distance = -1;
              _Height(_root,distance);
              return distance;
       }
protected:
       int _Height(Node* root, int& distance)
       {
              if (root == NULL)
              {
                     return 0;
              }
              int leftH = _Height(root->_left);
              int rightH = _Height(root->_right);
              if (leftH+rightH > distance)
              {
                     distance = leftH + rightH;
              }
              return leftH > rightH ? leftH+1 : rightH+1;、
       }

```

#### [和大于等于 target 的最短子数组](https://leetcode-cn.com/problems/2VG8Kg/)

```c++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, sum = 0;
        int minlen = INT_MAX;
        for(int right = 0; right < nums.size(); right++) {
            sum += nums[right];
            while(sum >= target && left <= right) {
                minlen = min(minlen, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }
        return minlen == INT_MAX ? 0 : minlen;
    }
};
```

#### [最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

```c++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        //string res = '';
        if(strs.empty()) return string();
        sort(strs.begin(), strs.end());
        string st = strs.front(), en = strs.back();
        int len = min(st.size(), en.size());
        int i;
        for(i = 0; i < len && st[i] == en[i]; i++);
        return string(st, 0, i);
    }
};
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.empty()) return "";
        int len = strs[0].size();
        int count = strs.size();
        for(int i = 0; i < len; i++) {
            char c = strs[0][i];
            for(int j = 0; j < count; j++) {
                if(i == strs[j].size() || c != strs[j][i]) {
                    return strs[0].substr(0, i);
                }
            }
        }
        return strs[0];
    }
};
```

#### 判断一个二叉树是否为完全二叉树

```c++
bool isCBT(node head) {
    if(head == NULL) return true;
    bool leaf = false;
    queue<node> q;
    q.push(head);
    while(!q.empty()) {
		node p = q.top();
        q.pop();
        if(leaf && (p.left !=NULL && p.right != NULL) || (p.left == null && p.right != null)) return false;
        if(p.left != null) {
			q.push(p.left);
        }
        if(p.right != null) {
			q.push(p.right);
        }
        if((p.left != null && p.right == null) || (p.left == null && p.right == null))
            left = true;
    }
    return true;
}
```

**二叉树的下一个结点**

```c++
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode) {
        if(pNode == NULL)
            return NULL;
        if(pNode->right != NULL) {
            pNode = pNode->right;
            while(pNode->left != NULL) {
                pNode = pNode->left;
            }
            return pNode;
        }
        while(pNode->next != NULL) {
            TreeLinkNode* proot = pNode->next;
            if(proot->left == pNode) {
                return proot;
            }
            pNode = pNode->next;
        }
        return NULL;
    }
};
```

#### [树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

```c++
class Solution {
public:
    bool isSubStructure(TreeNode* A, TreeNode* B) {
        if(A == NULL || B == NULL) {
            return false;
        }
        return rerur(A, B) || isSubStructure(A->left, B) || isSubStructure(A->right, B);
    }

    bool rerur(TreeNode* A, TreeNode* B) {
        if(B == NULL) return true;
        if(A == NULL) return false;
        if(A->val != B->val) return false;
        return rerur(A->left, B->left) && rerur(A->right, B->right);
    }
};
```

#### [最长公共子序列](https://leetcode-cn.com/problems/qJnOS7/)

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
       int m = text1.length(), n = text2.length();
       vector<vector<int>> dp(m + 1, vector<int>(n + 1));
       for(int i = 1; i <= m; i++) {
           char ch1 = text1.at(i - 1);
           for(int j = 1; j <= n; j++) {
               char ch2 = text2.at(j - 1);
               if(ch1 == ch2) {
                   dp[i][j] = dp[i - 1][j - 1] + 1;
               } else {
                   dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
               }
           }
       }
       return dp[m][n];
    }
};
```

#### [在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) 

##### 二分右边界左边界

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.empty()) return {-1, -1};
        int left = leftedgevector(nums, target);
        int right = rightedgevector(nums, target);
        if(left + 1> right) return {-1, -1};
        return {left, right - 1};
    }

    int rightedgevector(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while(l <= r) {
            int m = (l + r) / 2;
            if(nums[m] <= target) l = m + 1;
            else r = m - 1;
        }
        return l;
    }
    int leftedgevector(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while(l <= r) {
            int m = (l + r) / 2;
            if(nums[m] < target) l = m + 1;
            else r = m - 1;
        }
        return l;
    }
};
```

#### [分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

01背包

```c++
for(int i = 0; i < nums.size(); i++) {
	for(int j = target; j >= nums[i]; j--){
        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
    }
}
```

#### [最后一块石头的重量 II](https://leetcode-cn.com/problems/last-stone-weight-ii/)

#### [分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

01背包

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0;
        for(auto num : nums) {
            sum += num;
        }
        if(sum % 2 == 1) return false;
        int target = sum / 2;
        vector<int> dp(10001, 0);
        dp[0] = 0;
        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) {
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }
        return dp[target] == target ? true : false;
    }
};
```

#### [LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)

```c++
class LRUCache {
public:
    int capacity_;
    list<int> keyList_;
    unordered_map<int, pair<int, list<int>::iterator>> hashMap_;
    void insert(int key, int value) {
        keyList_.push_back(key);
        hashMap_[key] = make_pair(value, --keyList_.end());
    }

    LRUCache(int capacity) {
        capacity_ = capacity;
    }

    
    
    int get(int key) {
        auto it = hashMap_.find(key);
        if(it != hashMap_.end()) {
            keyList_.erase(it->second.second);
            keyList_.push_back(key);
            hashMap_[key].second = (--keyList_.end());
            return it->second.first;
        }
        return -1;
    }
    
    void put(int key, int value) {
        if(get(key) != -1) {
            hashMap_[key].first = value;
            return;
        }
        if(hashMap_.size() < capacity_) {
            insert(key, value);
        } else {
            int removeKey = keyList_.front();
            keyList_.pop_front();
            hashMap_.erase(removeKey);

            insert(key, value);
        }
    }
};
```



#### [正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

```c++
class Solution {
public:
    bool first_Match(string s, string p, int i, int j) {
        return s[i] == p[j] || p[j] == '.';
    }

    bool isMatch(string s, string p) {
        vector<vector<bool>> dp(s.size() + 1, vector<bool>(p.size() + 1));
        dp[0][0] = true;
        for(int j = 2; j <= p.size(); j++) {
            dp[0][j] = p[j - 1] == '*' && dp[0][j - 2];
        }
        for(int i = 0; i < s.size(); i++) {
            for(int j = 0; j < p .size(); j++) {
                if(p[j] == '*') {
                    dp[i + 1][j + 1] = dp[i + 1][j - 1] || first_Match(s, p, i, j - 1) && dp[i][j + 1]; // 第一种j前面一个字符没有出现，就匹配前2个，第二种j前一个字符出现了，判断首字符是否相同，首字符相同的情况下查看i - 1 和j的匹配情况
                }else {
                    dp[i + 1][j + 1] = first_Match(s, p, i, j) && dp[i][j];
                }
            }
        }
        return dp[s.size()][p.size()];
    }
};
```

#### [通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

#### [数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

```c++
class MedianFinder {
public:
    priority_queue<int, vector<int>, less<int>> maxheap; //保存较小的一半
    priority_queue<int, vector<int>, greater<int>> minheap; //保存较大的一半
    /** initialize your data structure here. */
    MedianFinder() {

    }
    
    void addNum(int num) {
        if(maxheap.size() != minheap.size()) {
            maxheap.push(num);
            minheap.push(maxheap.top());
            maxheap.pop();
        } else {
            minheap.push(num);
            maxheap.push(minheap.top());
            minheap.pop();
        }
    }
    
    double findMedian() {
        if(maxheap.size() != minheap.size()) {
            return maxheap.top() * 1.0;
        } else {
            return (maxheap.top() + minheap.top()) / 2.0;
        }
    }
};
```

#### [一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));
        for(auto str : strs) {
            int zeroNum = 0, oneNum = 0;
            for(auto ch : str) {
                if(ch == '0') {
                    zeroNum++;
                } else {
                    oneNum++;
                }
            }
            for(int i = m; i >= zeroNum; i--) {
                for(int j = n; j >= oneNum; j--) {
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                }
            }
        }
        return dp[m][n];
    }
};
```

#### [用 Rand7() 实现 Rand10()](https://leetcode-cn.com/problems/implement-rand10-using-rand7/)

```c++
class Solution {
public:
    int rand10() {
        int num = (rand7() - 1) * 7 + rand7();
        do{
            num = (rand7() - 1) * 7 + rand7();
        } while(num > 40);
        return 1 + num%10;
    }
};
```

#### [实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/) KMP

```c++
class Solution {
public:
    int strStr(string haystack, string needle) {
        if(needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for(int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if(haystack[i] == needle[j]) {
                j++;
            }
            if(j == needle.size()) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }

    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while(j > 0 && s[j] != s[i]) {
                j = next[j - 1];
            }
            if(s[j] == s[i]) {
                j++;
            }
            next[i] = j;
        }
    }
};
```

#### [重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/) 周期字符串

```c++
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        if(s.size() == 0) {
            return true;
        }
        int next[s.size()];
        getNext(next, s);
        int len = s.size();
        if(next[len - 1] != 0 && len % (len - next[len - 1]) == 0) {
            return true;
        }
        return false;
    }

    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while(j > 0 && s[j] != s[i]) {
                j = next[j - 1];
            }
            if(s[j] == s[i]) {
                j++;
            }
            next[i] = j;
        }
    }
};
```

#### [括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        dfs("", n, n, res);
        return res;
    }

    void dfs(string curStr, int left, int right, vector<string>& res) {
        if(left == 0 && right == 0) {
            res.push_back(curStr);
            return;
        }
        if(left > right) {
            return;
        }
        if(left > 0) {
            dfs(curStr + "(", left - 1, right, res);
        }
        if(right > 0) {
            dfs(curStr + ")", left, right - 1, res);
        }
    }
};
```

#### [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

```c++
class Solution {
public:
    int longestValidParentheses(string s) {
        int ans = 0;
        stack<int> st;
        st.push(-1);
        for(int i = 0; i < s.size(); i++) {
            if(s[i] == '(') {
                st.push(i);
            } else {
                st.pop();
                if(st.empty()) {
                    st.push(i);
                } else {
                    ans = max(ans, i - st.top());
                }
            }
        }
        return ans;
    }
};
```

#### [电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```c++
class Solution {
public:
    vector<string> res;
    string strs;
    const string lettersmap[10] = {
        "", //0
        "", //1
        "abc", //2
        "def", //3
        "ghi", //4
        "jkl", //5
        "mno", //6
        "pqrs", //7
        "tuv", //8
        "wxyz", //9
    };

    void backTracking(const string& digits, int index) {
        if(index == digits.length()) {
            res.push_back(strs);
            return;
        }
        int digit = digits[index] - '0';
        string letters = lettersmap[digit];
        for(int i = 0; i < letters.size(); i++) {
            strs.push_back(letters[i]);
            backTracking(digits, index + 1);
            strs.pop_back();
        }
    }

    vector<string> letterCombinations(string digits) {
        if(digits.empty()) return res;
        backTracking(digits, 0);
        return res;
    }
};
```

#### [分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

```c++
class Solution {
public:
    vector<vector<string>> res;
    vector<string> path;
    bool isValid(string& s, int left, int right) {
        while(left < right) {
            if(s[left++] != s[right--]) {
                return false;
            }
        }
        return true;
    }

    void backTracking(string s, int begin) {
        if(begin == s.size()) {
            res.push_back(path);
            return;
        }
        for(int end = begin; end < s.size(); end++) {
            if(isValid(s, begin, end)) {
                path.push_back(s.substr(begin, end - begin + 1));
                backTracking(s, end + 1);
                path.pop_back();
            }
        }
    }

    vector<vector<string>> partition(string s) {
        backTracking(s, 0);
        return res;
    }
};
```

图的DFS

```c++
void DFS(vector<vector<int>>& graph, int i, vector<bool>& visited) {
	visited[i] = true;
	for (int j = 0; j < graph[i].size(); j++) {
		cout << graph[i][j] << endl;
		if (graph[i][j] && !visited[j]) {
			DFS(graph, j, visited);
		}
	}
}

void DFSTraverse(vector<vector<int>>& graph) {
	int numVertexes = graph.size();
	vector<bool> visited(numVertexes, false);
	for (int i = 0; i < numVertexes; i++) {
		if (!visited[i]) {
			DFS(graph, i, visited);
		}
	}

}
```

#### [K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

```c++
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        return dfs(head, k, listLength(head));
    }

    ListNode* dfs(ListNode* head, int k, int len) {
        if(len < k) {
            return head;
        }
        ListNode* tail = head;
        ListNode* prev = nullptr, *temp = nullptr;
        for(int i = 0; i < k; ++i) {
            temp = head->next;
            head->next = prev;
            prev = head;
            head = temp;
        }
        tail->next = dfs(head, k, len - k);
        return prev;
    }

    int listLength(ListNode* head) {
        int len = 0;
        while(head != nullptr) {
            head = head->next;
            len++;
        }
        return len;
    }
};

ListNode* creatList(vector<int> myVec) {
	ListNode* pHead = new ListNode(myVec[0]);
	ListNode* prev = pHead;
	for (int i = 1; i < myVec.size(); i++) {
		pHead->next = new ListNode(myVec[i]);
		pHead = pHead->next;
	}
	return prev;
}
```

####  **链表内指定区间反转**

```c++
class Solution {
public:
    /**
     * 
     * @param head ListNode类 
     * @param m int整型 
     * @param n int整型 
     * @return ListNode类
     */
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        // write code here
        ListNode* dum = new ListNode(0);
        dum->next = head;
        ListNode* pre = dum;
        for(int i = 0; i < m - 1; i++){
            pre = pre->next;
        }
        ListNode* cur = pre->next;
        ListNode* Cur_Next = nullptr;
        for(int i = 0; i < n - m; i++){
            Cur_Next = cur->next;
            cur->next = Cur_Next->next;
            Cur_Next->next = pre->next;
            pre->next = Cur_Next;
        }
        return dum->next;
    }
};
```

#### [ 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1));

        for(int i = 0; i <= word1.size(); i++) {
            dp[i][0] = i;
        }
        for(int j = 0; j <= word2.size(); j++) {
            dp[0][j] = j;
        }

        for(int i = 1; i <= word1.size(); i++) {
            for(int j = 1; j <= word2.size(); j++) {
                if(word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

#### [合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

```c++
class Solution {
public:
    struct mycmp{
        bool operator()(ListNode* a, ListNode* b){
            return a->val > b->val;
        }
    };

    priority_queue<ListNode*, vector<ListNode*>, mycmp> pq;

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for(auto node : lists) {
            if(node) pq.push(node);
        }
        ListNode* head = new ListNode();
        ListNode* tail = head;
        while(!pq.empty()) {
            ListNode* Node = pq.top();
            pq.pop();
            tail->next = Node;
            tail = tail->next;
            if(Node->next) pq.push(Node->next);
        }
        return head->next;
    }
};
```

#### **数组中的逆序对**

```c++
class Solution {
public:
    const int kmod = 1000000007;
    int InversePairs(vector<int> data) {
        int ret = 0;
        vector<int> tmp(data.size());
        merge_sort(data, tmp, 0, data.size() - 1, ret);
        return ret;
    }
    
    void merge_sort(vector<int>& arr, vector<int>& tmp, int l, int r, int &ret){
        if(l >= r){
            return;
        }
        int mid = l + (r - l) / 2;
        merge_sort(arr, tmp, l, mid, ret);
        merge_sort(arr, tmp, mid + 1, r, ret);
        merge_(arr, tmp, l, mid, r, ret);
    }
    
    void merge_(vector<int>& arr, vector<int>& tmp, int l, int mid, int r, int& ret){
        int i = l, j = mid + 1, k = 0;
        while(i <= mid && j <= r){
            if(arr[i] > arr[j]){
                tmp[k++] = arr[j++];
                ret += (mid - i + 1);
                ret %= kmod;
            } else{
                tmp[k++] = arr[i++];
            }
        }
        while(i <= mid){
            tmp[k++] = arr[i++];
        }
        
        while(j <= r){
            tmp[k++] = arr[j++];
        }
        
        for(k = 0, i = l;i <= r; ++i, ++k){
            arr[i] = tmp[k];
        }
    }
};
```

#### [岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int res = 0;
        for(int r = 0; r < grid.size(); r++) {
            for(int c = 0; c < grid[0].size(); c++) {
                if(grid[r][c] == '1') {
                    res++;
                    dfs(grid, r, c);
                }
            }
        }
        return res;
    }

    void dfs(vector<vector<char>>& grid, int r, int c) {
        if(!isArea(grid, r, c)) {
            return;
        }

        if(grid[r][c] != '1') {
            return;
        }

        grid[r][c] = 2;

        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }

    bool isArea(vector<vector<char>>& grid, int r, int c) {
        return r >= 0 && r < grid.size() && c >= 0 && c < grid[0].size(); 
    }
};
```

#### c++实现指定字符的字符串分割

```c++
    vector<string> split(const string& str, char dec) {
        int pos = 0;
        int start = 0;
        vector<string> res;
        while(pos < str.size()){
            while(pos < str.size() && str[pos] == dec) {
                pos++;
            }
            start = pos;
            while(pos < str.size() && str[pos] != dec) {
                pos++;
            }
            if(start < str.size()) {
                res.emplace_back(str.substr(start, pos - start));
            }
        }
        return res;
    }
```

